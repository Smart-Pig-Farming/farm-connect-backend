import { Request, Response } from "express";
import { Op, WhereOptions } from "sequelize";
import DiscussionPost from "../models/DiscussionPost";
import DiscussionReply from "../models/DiscussionReply";
import User from "../models/User";
import Tag from "../models/Tag";
import PostMedia from "../models/PostMedia";
import ContentReport from "../models/ContentReport";
import PostSnapshot from "../models/PostSnapshot";
import ReportRateLimit from "../models/ReportRateLimit";
import { getWebSocketService } from "../services/webSocketService";
import notificationService from "../services/notificationService";

// Helper to parse decision input
const isValidDecision = (d: any): d is "retained" | "deleted" | "warned" =>
  d === "retained" || d === "deleted" || d === "warned";

class ModerationController {
  // Enhanced report creation with rate limiting and improved logic
  async createReport(req: Request, res: Response): Promise<void> {
    try {
      const userId = (req as any).user?.userId || (req as any).user?.id;
      const { id } = req.params; // content id (post or reply)
      const { reason, details } = req.body as {
        reason:
          | "inappropriate"
          | "spam"
          | "fraudulent"
          | "misinformation"
          | "technical"
          | "other";
        details?: string;
      };
      const contentType: "post" | "reply" = req.path.includes("/replies/")
        ? "reply"
        : "post";

      // 1. Validate target exists and is not deleted
      if (contentType === "post") {
        const post = await DiscussionPost.findByPk(id);
        if (!post || (post as any).is_deleted) {
          res.status(404).json({ success: false, error: "Post not found" });
          return;
        }
      } else {
        const reply = await DiscussionReply.findByPk(id);
        if (!reply) {
          res.status(404).json({ success: false, error: "Reply not found" });
          return;
        }
      }

      // 2. Check rate limiting
      const rateLimitResult = await ReportRateLimit.checkRateLimit(
        userId,
        id,
        contentType
      );
      
      if (!rateLimitResult.allowed) {
        res.status(429).json({
          success: false,
          error: rateLimitResult.reason === "hourly_limit_exceeded" 
            ? "Too many reports in the last hour" 
            : "Cannot report this content again so soon",
          retryAfter: rateLimitResult.retryAfter,
          reason: rateLimitResult.reason,
        });
        return;
      }

      // 3. Check for existing reports by this user for this content
      const existingReport = await ContentReport.findOne({
        where: {
          content_id: id,
          content_type: contentType,
          reporter_id: userId,
        },
        order: [["created_at", "DESC"]],
      });

      let report: any;

      if (existingReport) {
        if ((existingReport as any).status === "pending") {
          // Already has pending report - just return current state
          const reportCount = await ContentReport.count({
            where: {
              content_id: id,
              content_type: contentType,
              status: "pending",
            },
          });
          res.status(200).json({
            success: true,
            data: { duplicate: true, reportCount, existingReportId: existingReport.id },
          });
          return;
        } else if (this.canReopenReport(existingReport as any)) {
          // Reopen resolved report
          report = await this.reopenReport(existingReport as any, reason, details);
        } else {
          // Still in cooldown period
          const cooldownHours = parseInt(
            process.env.MODERATION_REOPEN_COOLDOWN_HOURS || "24",
            10
          );
          res.status(400).json({
            success: false,
            error: `Cannot report this content again for ${cooldownHours} hours after last decision`,
            cooldownHours,
          });
          return;
        }
      } else {
        // Create new report
        report = await ContentReport.create({
          content_id: id,
          content_type: contentType,
          reporter_id: userId,
          reason,
          details,
          status: "pending",
        });
      }

      // 4. Record rate limit entry
      await ReportRateLimit.recordReport(userId, id, contentType);

      // 5. Broadcast and notify
      await this.broadcastReport(report);
      await this.notifyContentOwner(report);

      // 6. Return response
      const reportCount = await ContentReport.count({
        where: {
          content_id: id,
          content_type: contentType,
          status: "pending",
        },
      });

      res.status(201).json({
        success: true,
        data: {
          id: report.id,
          reportCount,
          isReopened: !!existingReport,
        },
      });
    } catch (error: any) {
      console.error("Error creating report:", error);
      res.status(500).json({
        success: false,
        error: "Failed to create report",
        details: process.env.NODE_ENV === "development" ? error.message : undefined,
      });
    }
  }

  // Helper method to check if a report can be reopened
  private canReopenReport(existingReport: any): boolean {
    if (existingReport.status === "pending") return false;
    
    const cooldownHours = parseInt(
      process.env.MODERATION_REOPEN_COOLDOWN_HOURS || "24",
      10
    );
    
    if (!existingReport.resolved_at) return true; // No resolution time recorded
    
    const cooldownMs = cooldownHours * 60 * 60 * 1000;
    const timeSinceResolution = Date.now() - new Date(existingReport.resolved_at).getTime();
    
    return timeSinceResolution >= cooldownMs;
  }

  // Helper method to reopen an existing report
  private async reopenReport(existingReport: any, reason: string, details?: string): Promise<any> {
    existingReport.status = "pending";
    existingReport.reason = reason;
    existingReport.details = details;
    existingReport.decision = null;
    existingReport.moderator_id = null;
    existingReport.resolution_notes = null;
    existingReport.resolved_at = null;
    existingReport.created_at = new Date(); // Update to current time for ordering
    
    await existingReport.save();
    return existingReport;
  }

  // Helper method to broadcast report
  private async broadcastReport(report: any): Promise<void> {
    try {
      const ws = getWebSocketService();
      ws.broadcastContentReport({
        id: report.id,
        contentId: report.content_id,
        contentType: report.content_type,
        reason: report.reason,
        details: report.details,
        reporterId: report.reporter_id,
        created_at: report.created_at?.toISOString?.() || new Date().toISOString(),
      });
    } catch (error) {
      console.error("Failed to broadcast report:", error);
      // Don't fail the entire operation if broadcast fails
    }
  }

  // Helper method to notify content owner
  private async notifyContentOwner(report: any): Promise<void> {
    try {
      if (report.content_type === "post") {
        await notificationService.notifyContentReported(
          report.content_id,
          "post",
          report.reason
        );
      } else {
        await notificationService.notifyContentReported(
          report.content_id,
          "reply",
          report.reason
        );
      }
    } catch (error) {
      console.error("Failed to notify content owner:", error);
      // Don't fail the entire operation if notification fails
    }
  }

      // Broadcast to moderators and notify owner that content was reported
      const ws = getWebSocketService();
      ws.broadcastContentReport({
        id: report.id,
        contentId: report.content_id,
        contentType: report.content_type,
        reason: report.reason,
        details: report.details,
        reporterId: report.reporter_id,
        created_at:
          (report as any).created_at?.toISOString?.() ||
          new Date().toISOString(),
      });

      if (contentType === "post") {
        await notificationService.notifyContentReported(id, "post", reason);
      } else {
        await notificationService.notifyContentReported(id, "reply", reason);
      }

      // Return aggregate info
      const reportCount = await ContentReport.count({
        where: { content_id: id, content_type: contentType, status: "pending" },
      });

      res
        .status(201)
        .json({ success: true, data: { id: report.id, reportCount } });
    } catch (error: any) {
      if (error?.name === "SequelizeUniqueConstraintError") {
        // Duplicate report by same user for same open case
        const { id } = req.params;
        const contentType: "post" | "reply" = req.path.includes("/replies/")
          ? "reply"
          : "post";
        const reportCount = await ContentReport.count({
          where: {
            content_id: id,
            content_type: contentType,
            status: "pending",
          },
        });
        res
          .status(200)
          .json({ success: true, data: { duplicate: true, reportCount } });
        return;
      }
      console.error("Error creating report:", error);
      res
        .status(500)
        .json({ success: false, error: "Failed to create report" });
    }
  }

  // Get pending cases (group by content/post)
  async getPending(req: Request, res: Response): Promise<void> {
    try {
      const {
        search,
        page = "1",
        limit = "10",
      } = req.query as {
        search?: string;
        page?: string;
        limit?: string;
      };
      const pageNum = Math.max(parseInt(String(page), 10) || 1, 1);
      const limitNum = Math.min(
        Math.max(parseInt(String(limit), 10) || 10, 1),
        100
      );

      const reopenThreshold = parseInt(
        process.env.MODERATION_REOPEN_THRESHOLD || "1",
        10
      );
      const reopenCooldownMin = parseInt(
        process.env.MODERATION_REOPEN_COOLDOWN_MIN || "0",
        10
      );

      // Only posts for this first iteration
      const pendingReports = await ContentReport.findAll({
        where: { status: "pending", content_type: "post" },
        include: [
          {
            model: DiscussionPost,
            as: "post",
            include: [
              {
                model: User,
                as: "author",
                attributes: ["id", "firstname", "lastname"],
              },
              {
                model: Tag,
                as: "tags",
                attributes: ["name"],
                through: { attributes: [] },
              },
              {
                model: PostMedia,
                as: "media",
                attributes: [
                  "id",
                  "media_type",
                  "url",
                  "thumbnail_url",
                  "display_order",
                ],
                separate: true,
              },
            ],
          },
          {
            model: User,
            as: "reporter",
            attributes: ["id", "firstname", "lastname"],
          },
        ],
        order: [["created_at", "DESC"]],
      });

      // Compute last decision per post for reopen logic
      const postIds = Array.from(
        new Set((pendingReports as any[]).map((r) => r.content_id))
      );
      const lastResolvedRows = await ContentReport.findAll({
        where: {
          content_type: "post",
          status: "resolved",
          content_id: postIds,
        },
        order: [["resolved_at", "DESC"]],
      });
      const lastResolvedAtByPost = new Map<string, Date>();
      for (const r of lastResolvedRows as any[]) {
        const pid = r.content_id as string;
        if (!lastResolvedAtByPost.has(pid) && r.resolved_at) {
          lastResolvedAtByPost.set(pid, new Date(r.resolved_at));
        }
      }

      // Group by post and apply reopen threshold/cooldown rules
      const map = new Map<string, any>();
      for (const r of pendingReports as any[]) {
        const pid = r.content_id;
        const entry = map.get(pid) || {
          postId: pid,
          post: r.post,
          reports: [] as any[],
        };
        entry.reports.push({
          id: r.id,
          reason: r.reason,
          details: r.details,
          reporter: r.reporter,
          created_at: r.created_at,
        });
        map.set(pid, entry);
      }

      let items = Array.from(map.values());

      // Apply reopen logic
      const now = new Date();
      items = items.filter((it) => {
        const lastResolved = lastResolvedAtByPost.get(it.postId);
        if (!lastResolved) return true; // no prior decision
        // Cooldown: skip if within cooldown window
        if (reopenCooldownMin > 0) {
          const ms = reopenCooldownMin * 60 * 1000;
          if (now.getTime() - lastResolved.getTime() < ms) return false;
        }
        // Threshold: number of reports after last decision
        const countAfterDecision = it.reports.filter(
          (r: any) => new Date(r.created_at) > lastResolved
        ).length;
        return countAfterDecision >= reopenThreshold;
      });
      if (search) {
        const q = search.toLowerCase();
        items = items.filter(
          (it) =>
            String(it.post.title).toLowerCase().includes(q) ||
            String(it.post.author.firstname + " " + it.post.author.lastname)
              .toLowerCase()
              .includes(q)
        );
      }

      // Summaries
      const summarized = items.map((it) => ({
        postId: it.postId,
        reportCount: it.reports.length,
        mostCommonReason:
          it.reports.reduce((acc: Record<string, number>, r: any) => {
            acc[r.reason] = (acc[r.reason] || 0) + 1;
            return acc;
          }, {} as Record<string, number>) &&
          Object.entries(
            it.reports.reduce((acc: Record<string, number>, r: any) => {
              acc[r.reason] = (acc[r.reason] || 0) + 1;
              return acc;
            }, {} as Record<string, number>)
          ).sort((a: any, b: any) => b[1] - a[1])[0][0],
        post: it.post,
        reports: it.reports,
      }));

      // Search filter
      let filtered = summarized;
      if (search) {
        const q = search.toLowerCase();
        filtered = summarized.filter(
          (it) =>
            String(it.post.title).toLowerCase().includes(q) ||
            String(it.post.author.firstname + " " + it.post.author.lastname)
              .toLowerCase()
              .includes(q)
        );
      }

      const total = filtered.length;
      const start = (pageNum - 1) * limitNum;
      const end = start + limitNum;
      const data = filtered.slice(start, end);
      res.json({
        success: true,
        data,
        pagination: {
          page: pageNum,
          limit: limitNum,
          total,
          totalPages: Math.max(Math.ceil(total / limitNum), 1),
          hasNextPage: end < total,
        },
      });
    } catch (error) {
      console.error("Error fetching pending moderation:", error);
      res
        .status(500)
        .json({ success: false, error: "Failed to fetch pending" });
    }
  }

  // Decide on a post reports
  async decide(req: Request, res: Response): Promise<void> {
    try {
      const moderatorId = (req as any).user?.userId || (req as any).user?.id;
      const { postId } = req.params;
      const { decision, justification } = req.body as {
        decision: "retained" | "deleted" | "warned";
        justification: string;
      };

      if (!isValidDecision(decision)) {
        res.status(400).json({ success: false, error: "Invalid decision" });
        return;
      }
      if ((decision === "deleted" || decision === "warned") && !justification) {
        res
          .status(400)
          .json({ success: false, error: "Justification required" });
        return;
      }

      const post = await DiscussionPost.findByPk(postId, {
        include: [
          {
            model: User,
            as: "author",
            attributes: ["id", "firstname", "lastname"],
          },
        ],
      });
      if (!post) {
        res.status(404).json({ success: false, error: "Post not found" });
        return;
      }

      // Fetch all pending reports for this post
      const reports = await ContentReport.findAll({
        where: { content_id: postId, content_type: "post", status: "pending" },
        include: [{ model: User, as: "reporter", attributes: ["id"] }],
      });

      const reportCount = reports.length;

      // Apply decision effects
      if (decision === "deleted") {
        (post as any).is_deleted = true;
        await post.save();
        // Broadcast deletion so clients update feeds immediately
        try {
          const ws = getWebSocketService();
          ws.broadcastPostDelete(postId);
        } catch (e) {
          console.error("WebSocket broadcast delete failed:", e);
        }
      }

      // Mark reports as resolved with decision snapshot
      const now = new Date();
      for (const r of reports) {
        r.status = "resolved";
        (r as any).decision = decision as any;
        (r as any).moderator_id = moderatorId;
        (r as any).resolution_notes = justification;
        (r as any).resolved_at = now as any;
        await r.save();
      }

      // Send notifications
      const reporterIds = Array.from(
        new Set(reports.map((r: any) => r.reporter_id))
      );

      // Broadcast decision for dashboards
      const ws = getWebSocketService();
      ws.broadcastModerationDecision({
        postId: postId,
        decision,
        justification,
        moderatorId,
        decidedAt: now.toISOString(),
        reportCount,
      });

      // Send in-app notifications
      for (const rid of reporterIds) {
        await notificationService.createNotification({
          recipientId: rid,
          type: "moderation_decision_reporter" as any,
          triggerUserId: moderatorId,
          data: {
            postId,
            postTitle: (post as any).title,
            decision,
            justification,
          },
        });
      }

      await notificationService.createNotification({
        recipientId: (post as any).author.id,
        type: "moderation_decision_owner" as any,
        triggerUserId: moderatorId,
        data: {
          postId,
          postTitle: (post as any).title,
          decision,
          justification,
        },
      });

      res.json({ success: true, data: { postId, decision, reportCount } });
    } catch (error) {
      console.error("Error applying moderation decision:", error);
      res
        .status(500)
        .json({ success: false, error: "Failed to apply decision" });
    }
  }

  // History with filters and basic metrics dimensions
  async getHistory(req: Request, res: Response): Promise<void> {
    try {
      const {
        from,
        to,
        decision,
        page = "1",
        limit = "10",
      } = req.query as {
        from?: string;
        to?: string;
        decision?: "retained" | "deleted" | "warned";
        page?: string;
        limit?: string;
      };
      const pageNum = Math.max(parseInt(String(page), 10) || 1, 1);
      const limitNum = Math.min(
        Math.max(parseInt(String(limit), 10) || 10, 1),
        100
      );

      const where: WhereOptions = { content_type: "post", status: "resolved" };
      if (decision) (where as any).decision = decision;
      if (from)
        (where as any).resolved_at = { [Op.gte]: new Date(from) } as any;
      if (to)
        (where as any).resolved_at = {
          ...(where as any).resolved_at,
          [Op.lte]: new Date(to),
        } as any;

      const rows = await ContentReport.findAll({
        where,
        include: [
          {
            model: DiscussionPost,
            as: "post",
            include: [
              {
                model: User,
                as: "author",
                attributes: ["id", "firstname", "lastname"],
              },
            ],
            attributes: ["id", "title"],
          },
          {
            model: User,
            as: "moderator",
            attributes: ["id", "firstname", "lastname"],
          },
        ],
        order: [["resolved_at", "DESC"]],
      });

      // Group by postId (latest decision)
      const groups = new Map<string, any>();
      for (const r of rows as any[]) {
        const key = `${r.content_id}`;
        const g = groups.get(key) || {
          postId: r.content_id,
          decision: r.decision,
          moderator: r.moderator,
          decidedAt: r.resolved_at,
          count: 0,
        };
        g.count += 1;
        groups.set(key, g);
      }

      const all = Array.from(groups.values());
      const total = all.length;
      const start = (pageNum - 1) * limitNum;
      const end = start + limitNum;
      const data = all.slice(start, end).map((g) => ({
        ...g,
        post: g.post || undefined,
      }));

      res.json({
        success: true,
        data,
        pagination: {
          page: pageNum,
          limit: limitNum,
          total,
          totalPages: Math.max(Math.ceil(total / limitNum), 1),
          hasNextPage: end < total,
        },
      });
    } catch (error) {
      console.error("Error fetching moderation history:", error);
      res
        .status(500)
        .json({ success: false, error: "Failed to fetch history" });
    }
  }

  // Metrics endpoint: minimal KPIs requested
  async getMetrics(req: Request, res: Response): Promise<void> {
    try {
      const now = new Date();
      const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);

      const rows = await ContentReport.findAll({
        attributes: [
          "id",
          "content_id",
          "content_type",
          "reporter_id",
          "status",
          "created_at",
          "resolved_at",
          "decision",
        ],
        where: { content_type: "post" },
        order: [["created_at", "ASC"]],
      });

      const firstReportAt = new Map<string, Date>();
      const firstDecisionAt = new Map<string, Date>();
      const reportsPerPost = new Map<string, number>();
      const reportsPerReporter = new Map<number, number>();
      const distribution: Record<string, number> = {
        retained: 0,
        deleted: 0,
        warned: 0,
      };

      for (const r of rows as any[]) {
        const key = r.content_id;
        if (!firstReportAt.has(key))
          firstReportAt.set(key, new Date(r.created_at));
        if (
          r.status === "resolved" &&
          r.resolved_at &&
          !firstDecisionAt.has(key)
        ) {
          firstDecisionAt.set(key, new Date(r.resolved_at));
        }
        reportsPerPost.set(key, (reportsPerPost.get(key) || 0) + 1);
        reportsPerReporter.set(
          r.reporter_id,
          (reportsPerReporter.get(r.reporter_id) || 0) + 1
        );
        if (r.decision)
          distribution[r.decision] = (distribution[r.decision] || 0) + 1;
      }

      const timeToFirstDecisionSeconds: number[] = [];
      for (const [key, created] of firstReportAt.entries()) {
        const decided = firstDecisionAt.get(key);
        if (decided)
          timeToFirstDecisionSeconds.push(
            (decided.getTime() - created.getTime()) / 1000
          );
      }

      // Reopened within 30 days
      const resolvedByPost = new Map<string, Date[]>();
      for (const r of rows as any[]) {
        if (r.status === "resolved" && r.resolved_at) {
          const arr = resolvedByPost.get(r.content_id) || [];
          arr.push(new Date(r.resolved_at));
          resolvedByPost.set(r.content_id, arr);
        }
      }
      let reopenedCasesWithin30Days = 0;
      for (const [postId, dates] of resolvedByPost.entries()) {
        const hasRecent = dates.some((d) => d >= thirtyDaysAgo);
        if (!hasRecent) continue;
        const lastResolved = dates.sort((a, b) => b.getTime() - a.getTime())[0];
        const hasNewPending = (rows as any[]).some(
          (r) =>
            r.content_id === postId &&
            r.status === "pending" &&
            new Date(r.created_at) > lastResolved
        );
        if (hasNewPending) reopenedCasesWithin30Days += 1;
      }

      res.json({
        success: true,
        data: {
          timeToFirstDecisionSeconds,
          reportsPerPost: Object.fromEntries(reportsPerPost),
          reportsPerReporter: Object.fromEntries(reportsPerReporter),
          decisionDistribution: distribution,
          reopenedCasesWithin30Days,
        },
      });
    } catch (error) {
      console.error("Error fetching moderation metrics:", error);
      res
        .status(500)
        .json({ success: false, error: "Failed to fetch metrics" });
    }
  }
}

export default new ModerationController();
